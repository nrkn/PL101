start =
    expression
  
expression =
    repeat
  / subsequences: subsequence*
        {
          var result = [],
              initial = {
                modifier: { arg: 'n' },
                octave: { arg: 4 },
                len: { arg: 1 },
                tempo: { arg: 120 }
              };
          
          for( var i = 0; i < subsequences.length; i++ ) {
            var subsequence = subsequences[ i ],
                defines = subsequence.defines,
                elements = subsequence.elements;
                
            //if the first element in the sequence has any undefineds, use the initial settings
            if( i == 0 ) {
              defines.modifier = defines.modifier ? defines.modifier : initial.modifier;
              defines.octave = defines.octave ? defines.octave : initial.octave;
              defines.len = defines.len ? defines.len : initial.len;
              defines.tempo = defines.tempo ? defines.tempo : initial.tempo;
            } else {
              //otherwise if an element has any undefined, copy them from the previous element
              defines.modifier = defines.modifier ? defines.modifier : subsequences[ i  - 1 ].defines.modifier;
              defines.octave = defines.octave ? defines.octave : subsequences[ i  - 1 ].defines.octave;
              defines.len = defines.len ? defines.len : subsequences[ i  - 1 ].defines.len;
              defines.tempo = defines.tempo ? defines.tempo : subsequences[ i  - 1 ].defines.tempo;
            }
            
            var msPerBeat = 60000 / ( defines.tempo.arg / 4 );
            
            for( var e = 0; e < elements.length; e++ ) {
              var element = elements[ e ],
                  musElement = {
                    tag: element.tag,
                    dur: msPerBeat / ( element.duration !== '' ? element.duration : defines.len.arg )
                  };
                  
              //each . in the mml format extends the duration by half again
              if( element.extend > 0  ) {
                musElement.dur *= Math.pow( 1.5, element.extend );
              }

              if( element.tag === 'note' ) {
                musElement.pitch = element.note + element.accidental + defines.octave.arg;                
                //legato
                if( defines.modifier.arg === 'l' ) {
                  result.push( musElement );
                } else {          
                  //staccato or normal
                  var mod = defines.modifier.arg === 's' ? 0.75 : 0.875,
                      restMod = 1 - mod;
                      rest = {
                        tag: 'rest',
                        dur: musElement.dur * restMod
                      };
                  musElement.dur *= mod;
                  result.push( musElement );
                  result.push( rest );                
                }
              } else {
                result.push( musElement );
              }               
            }
          }
          
          if( result.length === 0 ) {
            return undefined;
          }
          
          if( result.length === 1 ) {
            return result[ 0 ];
          }

          var mus = {
                tag: 'seq',
                left: {},
                right: {}
              },
              lastSeq = mus,
              thisSeq = {};
          
          for( var i = 0; i < result.length; i++ ) {
            if( i < result.length - 1 ) {
              thisSeq = lastSeq;
              lastSeq.left = result[ i ];
              lastSeq = lastSeq.right = {
                tag: 'seq',
                left: {},
                right: {}
              };
            } else {
              thisSeq.right = result[ i ];
            }
          }     
          
          return mus;
        }        

digit =
    [0-9]
    
integer =
    digits: digit+ 
        { return parseInt( digits.join( '' ), 10 ); }
        
whitespace =
    [ \t\r\n]
    
noteletter =
    letter: [a-g]i
        { return letter.toLowerCase(); }

accidental =
    sign: [+#-]
        { return sign === '+' || sign === '#' ? '#' : 'b'; }
        
duration =
    integer
        
note =
    whitespace* noteletter: noteletter accidental: accidental? duration: duration? extend: '.'* whitespace*
        { 
          return { 
            tag: 'note',
            note: noteletter, 
            accidental: accidental,
            duration: duration,
            extend: extend.length
          };
        }

rest =
    whitespace* [pr]i duration: duration? extend: '.'* whitespace*
        {
          return {
            tag: 'rest',
            duration: duration,
            extend: extend.length
          };
        }    

element =
    note
  / rest 

modifier =
    whitespace* 'm'i whitespace* arg: [fblsn]i whitespace* 
        {  
          return {
            tag: 'modifier',
            arg: arg
          };
        }
        
tempo =
    whitespace* 't'i whitespace* arg: integer whitespace* 
        {
          return {
            tag: 'tempo',
            arg: arg
          };
        }
        
octave =
    whitespace* 'o'i whitespace* arg: [0-6] whitespace* 
        {
          return {
            tag: 'octave',
            arg: parseInt( arg, 10 )
          }
        }
        
len =
    whitespace* 'l'i whitespace* arg: duration whitespace* 
        {
          return {
            tag: 'len',
            arg: arg
          };
        }

define =
    modifier
  / tempo
  / octave
  / len

defines = 
    defines: define* 
        {
          var result = {};
        
          
          for( var i = 0; i < defines.length; i++ ) {
            result[ defines[ i ].tag ] = defines[ i ];
          }
          
          
          return result;
        }

subsequence =
    defines: defines elements: element+
        { 
          return {
            tag: 'subsequence',
            defines: defines,
            elements: elements
          };
        }
        
repeat = 
    whitespace* '*' whitespace* times: integer whitespace* '(' whitespace* expression: expression whitespace* ')' whitespace*
        {
          return {
            tag: 'repeat',
            expression: expression,
            times: times
          };
        }